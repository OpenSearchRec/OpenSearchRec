import datetime
from pydantic import BaseModel, Field, Extra, validator
from typing import List, Optional, Union, Dict, Any, Type

from OpenSearchRec.retrieval.models.common import (
    FieldTypeNamesAndPrefixes,
    GeolocationField,
    raise_exception_if_field_name_not_valid,
    raise_exception_if_geolocation_field_value_not_valid
)


class SearchItem(BaseModel):
    id: Optional[str] = Field(None, description="Item ID in the index (autogenerated if not provided)")

    text_fields: Optional[Dict[str, str]] = \
        Field(None, description="")

    categorical_fields: Optional[Dict[str, Union[str, List[str]]]] = \
        Field(None, description="")

    numeric_fields: Optional[Dict[str, float]] = \
        Field(None, description="")

    date_fields: Optional[Dict[str, Optional[datetime.datetime]]] = \
        Field(None, description="")

    geolocation_fields: Optional[Dict[str, GeolocationField]] = \
        Field(None, description="")

    embedding_fields: Optional[Dict[str, List[float]]] = \
        Field(None, description="Dimension of SearchItem embeddings.")

    extra_information: Dict[str, Any] = Field(None)

    @validator(
        *[n.name for n in FieldTypeNamesAndPrefixes],
        pre=True
    )
    def validate_embedding_configs(cls, value, values, config, field):
        for field_name in value:
            raise_exception_if_field_name_not_valid(field_name)
        return value

    @validator("id", pre=True)
    def validate_id(cls, value, values, config, field):
        if value is not None:
            raise_exception_if_field_name_not_valid(value)
        return value

    class Config:
        extra = Extra.forbid

        @staticmethod
        def schema_extra(schema: Dict[str, Any], model: Type['SearchItem']) -> None:
            schema["properties"]["id"]["default"] = "id"
            schema["properties"]["text_fields"]["default"] = {
                "title": "title",
                "description": "description",
                "source_name": "source_name"
            }
            schema["properties"]["categorical_fields"]["default"] = {
                "tags": ["tag1", "tag2", "tag3"],
                "authors": "author"
            }
            schema["properties"]["numeric_fields"]["default"] = {
                "popularity": 1000000,
                "quality_signal": 4.9
            }
            schema["properties"]["date_fields"]["default"] = {
                "published_date": (datetime.datetime.utcnow() - datetime.timedelta(days=365)).replace(microsecond=0),
                "last_updated_date": datetime.datetime.utcnow()
            }
            schema["properties"]["geolocation_fields"]["default"] = {
                "location": {"latitude": 0.0, "longitude": 0.0}
            }
            schema["properties"]["embedding_fields"]["default"] = {
                "embedding1_name": [1, 2, 3, 4, 5],
                "embedding2_name": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
            }
            schema["properties"]["extra_information"]["default"] = {
                "image_urls": [
                    "http://localhost:80/image1.pg",
                    "http://localhost:80/image2.pg",
                ]
            }

    def to_flat_mapping_dict(self, convert_datetimes_to_string=False):
        """Creates a flat dictionary of the instance"""
        if self.id is not None:
            mapping = {"id": self.id}
        else:
            mapping = {}
        if self.extra_information is not None:
            mapping["extra_information"] = self.extra_information

        self_dict = self.dict(exclude_unset=True)
        for field_type in FieldTypeNamesAndPrefixes:
            field_type_name = field_type.name
            field_type_prefix = field_type.value
            if field_type_name in self_dict:
                for field_name, value in self_dict[field_type_name].items():
                    if field_type == FieldTypeNamesAndPrefixes.date_fields:
                        if convert_datetimes_to_string:
                            if value is not None:
                                value = value.strftime("%Y-%m-%dT%H:%M:%S.%f")
                    if field_type == FieldTypeNamesAndPrefixes.geolocation_fields:
                        value = {"lat": value["latitude"], "lon": value["longitude"]}
                    mapping[field_type_prefix + field_name] = value
        return mapping

    def json_serializable_dict(exclude_unset=True):
        search_item_dictionary = super().dict(exclude_unset=exclude_unset)
        for date_field in search_item_dictionary.get("date_fields", {}):
            search_item_dictionary["date_fields"][date_field] = \
                str(search_item_dictionary["date_fields"][date_field])
        return search_item_dictionary

    @classmethod
    def from_flat_mapping_dict(cls, flat_item_dict, parse_date_strings_to_datetime=True):
        """ Create a SearchItem from a dictionary as generated by to_flat_mapping_dict"""
        if "id" in flat_item_dict:
            new_mapping = {
                "id": str(flat_item_dict["id"]) if flat_item_dict["id"] is not None else None,
            }
        else:
            new_mapping = {}

        if "extra_information" in flat_item_dict and flat_item_dict["extra_information"] is not None:
            new_mapping["extra_information"] = flat_item_dict["extra_information"]

        for field_type in FieldTypeNamesAndPrefixes:
            field_type_name = field_type.name
            mappings_for_field_types = {}
            field_type_prefix = field_type.value
            for field_name, field_value in flat_item_dict.items():
                if field_name.startswith(field_type_prefix):
                    new_mapping_field_name = field_name[len(field_type_prefix):]
                    raise_exception_if_field_name_not_valid(new_mapping_field_name)
                    if field_type == FieldTypeNamesAndPrefixes.date_fields:
                        if type(field_value) == str:    
                            mappings_for_field_types[new_mapping_field_name] = datetime.datetime.strptime(field_value, "%Y-%m-%dT%H:%M:%S.%f")
                        else:
                            mappings_for_field_types[new_mapping_field_name] = field_value

                    elif field_type == FieldTypeNamesAndPrefixes.geolocation_fields:
                        mappings_for_field_types[new_mapping_field_name] = {
                            "longitude": field_value["lon"],
                            "latitude": field_value["lat"],
                        }
                    else:
                        mappings_for_field_types[new_mapping_field_name] = field_value
            if len(mappings_for_field_types) > 0:
                new_mapping[field_type_name] = mappings_for_field_types
        return SearchItem(**new_mapping)

    def get(self, field_type, default_value=None):
        if getattr(self, field_type) is not None:
            return getattr(self, field_type)
        elif default_value is not None:
            return default_value
        else:
            raise Exception(f"{field_type} not found")

    def __getitem__(self, field_type):
        return self.get(field_type)

    def __contains__(self, field_type):
        return getattr(self, field_type) is not None
